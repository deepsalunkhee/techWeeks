
# Java EE & Spring: Complete Conceptual Guide

## 1Ô∏è‚É£ Core Java ‚Äî Enterprise-level Understanding

### JVM & Memory

**What happens when a Java program starts?**

- JVM loads, initializes, and verifies bytecode
- Creates runtime data areas (heap, stack, method area)
- Loads main class via classloader
- Executes static initializers
- Calls main() method

**Memory Regions:**

- **Heap**: All objects and their instance variables live here. Shared across all threads. Garbage collected.
- **Stack**: Each thread gets its own stack. Stores method frames, local variables, partial results. Destroyed when thread ends.
- **Metaspace**: Class metadata, method information, static variables. Replaced PermGen in Java 8+.

**Why each thread has its own stack?** Thread-local data must be isolated. Each method call needs its own local variables and execution context. Stacks are LIFO structures perfect for method call hierarchies.

**Long-lived objects in enterprise apps:**

- Singleton services (Spring beans, EJBs)
- Connection pools, thread pools
- Caches
- Application configuration
- Framework infrastructure

**Why memory leaks happen:**

- Objects referenced but never used (forgotten listeners, static collections)
- ThreadLocal variables not cleaned up
- Classloader leaks during redeployment
- External resource references not closed

### Classloading

**What is a classloader?** Loads class bytecode into JVM memory. Creates Class objects from .class files.

**Why multiple classloaders?**

- **Isolation**: Different versions of same class in different contexts
- **Security**: Control what code can be loaded
- **Lazy loading**: Load classes only when needed
- **Hot reload**: Reload classes without restarting JVM

**In application servers:** Each application gets its own classloader (WAR classloader). Allows multiple apps with different library versions to coexist.

**Problems with multiple classloaders:**

- Same class loaded by different classloaders = different Class objects
- ClassCastException even when classes look identical
- Static variables not shared across classloaders
- Breaks singleton pattern if not careful

**Redeployment memory leaks:** Old classloader held in memory because some object reference still exists. Entire old application stays in memory. Multiple redeployments = multiple dead applications in memory.

### Garbage Collection

**When does GC run?** When heap memory pressure occurs. You cannot predict or force it reliably. JVM decides based on heap usage and GC algorithm.

**Server vs Desktop GC:**

- **Server**: Large heaps, long-running processes, throughput matters more
- **Desktop**: Small heaps, responsive UI matters most
- Different GC algorithms optimized for each

**Stop-the-world problem:** All application threads pause during certain GC phases. In web applications, requests freeze. Users see timeout errors. Can last milliseconds to seconds.

**Why tune GC in production?**

- Default settings don't fit all workloads
- Poor GC = poor response times
- Right GC algorithm = fewer pauses
- Proper heap sizing = better throughput

### Immutability & Thread Safety

**Immutable class requirements:**

- All fields final
- No setter methods
- No methods that modify state
- Proper construction (no 'this' escape)
- Defensive copies if containing mutable objects

**Why immutable = thread-safe?** No state changes = no synchronization needed. Multiple threads can read safely. No race conditions possible.

**Why String is immutable:**

- Security: Used in classloading, security checks
- Hash code caching: For HashMap keys
- String pool: Memory efficiency
- Thread safety: Shared everywhere safely

**Problems with mutable shared state:**

- Race conditions: Multiple threads modify same data
- Visibility issues: Changes not seen by other threads
- Inconsistent state: Partial updates visible
- Hard to debug: Non-deterministic failures

### Concurrency

**Multiple threads, one object:**

- Without synchronization: Data corruption, inconsistent state
- Race conditions, lost updates
- Visibility problems (CPU caches)

**What synchronized locks:**

- Locks the object's intrinsic lock (monitor)
- `synchronized(this)` locks current object
- `synchronized(SomeClass.class)` locks class object
- Static synchronized locks the Class object

**Intrinsic vs Explicit locks:**

- **Intrinsic**: Built-in, automatic release, simple
- **Explicit (ReentrantLock)**: More features (try-lock, interruptible, fair/unfair, multiple conditions)

**Thread pools vs manual threads:**

- Thread pools reuse threads (expensive to create)
- Limit concurrent threads (prevent resource exhaustion)
- Better throughput, controlled resources
- Manual threads = poor scalability

**Race condition:** Outcome depends on timing/ordering of thread execution. Non-deterministic. Example: checking-then-acting on shared state.

**Why servlets are multi-threaded:** Single servlet instance handles all requests. Multiple threads call service() simultaneously. Designed for scalability. Each request gets own thread from pool.

### Exceptions

**Checked vs Unchecked:**

- **Checked**: Compile-time enforcement, recoverable conditions (IOException)
- **Unchecked**: Runtime, programming errors (NullPointerException)

**When to throw checked:** When caller can reasonably recover. When it's part of method contract. When it represents expected failure modes.

**Why frameworks prefer runtime exceptions:**

- Less boilerplate (no try-catch everywhere)
- Cleaner code, better composition
- Most enterprise errors aren't recoverable at call site
- Transaction management works better

**Exceptions and transactions:**

- Runtime exceptions trigger automatic rollback
- Checked exceptions don't (by default)
- Exception crosses transaction boundary = rollback
- Important for data consistency

---

## 2Ô∏è‚É£ Enterprise Architecture Mental Model

### Architecture Basics

**Why layered architecture?**

- **Separation of concerns**: Each layer has single responsibility
- **Maintainability**: Change one layer without affecting others
- **Testability**: Mock dependencies layer by layer
- **Team organization**: Different teams own different layers

**Layer responsibilities:**

- **Controller**: HTTP concerns, request/response, validation, routing
- **Service**: Business logic, orchestration, transactions
- **Repository**: Data access, queries, persistence

**Never in Controller:**

- Business logic
- Database queries
- Transaction management
- Complex validations

**Never in Repository:**

- Business logic
- Transaction boundaries (usually)
- HTTP concerns
- Formatting/presentation logic

### Monolith vs Distributed

**Monolithic application:** Single deployable unit. All features in one codebase. Runs in one process. Database is shared.

**Distributed system:** Multiple services, multiple processes. Communicate over network. Separate databases (ideally). Independent deployment.

**Why distributed is harder:**

- **Network unreliability**: Calls can fail, timeout, retry
- **Data consistency**: No ACID across services
- **Debugging**: Logs scattered across services
- **Deployment complexity**: Coordinating multiple deployments
- **Testing**: Integration tests need all services

**New problems in distributed systems:**

- Network latency, partial failures
- Distributed transactions (avoid them!)
- Service discovery, load balancing
- Eventual consistency
- Monitoring, tracing
- Version compatibility

### Communication Types

**HTTP calls:**

- Request-response over TCP
- Text-based protocol
- Platform independent
- Stateless by design
- Firewall friendly

**Remote method calls (RMI, gRPC):**

- Looks like local method call
- Hides network details
- Binary protocols often
- Tightly coupled (shared interfaces)
- Less firewall friendly

**Messaging (JMS, Kafka):**

- Asynchronous, fire-and-forget
- Queue or topic based
- Decouples sender/receiver
- Handles backpressure
- Reliable delivery

**Why HTTP is stateless:** No session memory between requests. Each request independent. Scalability: any server handles any request. Simplicity: no server-side session state.

**Why RMI is tightly coupled:** Shared interface definitions. Both sides must agree on method signatures. Version changes break things. Tight deployment coordination needed.

**Why messaging is loosely coupled:** Sender doesn't know receiver. Receiver doesn't know sender. Message schema is contract. Can evolve independently. Time-decoupled (sender/receiver don't run simultaneously).

---

## 3Ô∏è‚É£ Java EE / Jakarta EE Core Concepts

### a) Application Server

**What is it?** Runtime container that provides enterprise services. Manages application lifecycle. Provides infrastructure (connection pooling, security, transactions, messaging).

**Responsibilities taken from developer:**

- Thread management
- Connection pooling
- Transaction management
- Security enforcement
- Clustering/failover
- Deployment/lifecycle
- Resource management

**Tomcat vs WildFly/GlassFish:**

- **Tomcat**: Servlet container only. Lightweight. No full Java EE.
- **WildFly/GlassFish**: Full application servers. Complete Java EE stack. EJB, JMS, JTA, etc.

**"Container-managed" meaning:** Container controls the lifecycle and behavior. Container creates instances. Container injects dependencies. Container manages transactions. Developer declares intent, container handles implementation.

**Without application server:** You manage everything yourself. Manual connection pooling. Manual transaction handling. Manual thread pools. More code, more complexity. Spring Boot does much of this.

### b) Servlets & Filters

**What is a servlet?** Java class that handles HTTP requests. Container creates and manages it. Entry point for web requests.

**Servlet lifecycle:**

1. `init()` - Called once when servlet first loaded
2. `service()` - Called for each request (delegates to doGet, doPost, etc.)
3. `destroy()` - Called once when servlet unloaded

**Why init() once?** Servlet is singleton. Expensive initialization done once. Shared across all requests.

**Why service() many times?** One call per HTTP request. Multiple threads call it simultaneously. Must be thread-safe.

**Thread safety in servlets:** Single instance, many threads. Instance variables shared across threads. Use local variables or synchronization. Or make instance variables final/immutable.

**What is a filter?** Preprocessing/postprocessing for requests and responses. Can modify, block, or pass through. Chain of filters before servlet.

**Filters vs Servlets:**

- Filters don't generate responses (usually)
- Filters reusable across servlets
- Filters for cross-cutting concerns (logging, security, compression)

**Filter position in request flow:** Browser ‚Üí Server ‚Üí Filters (chain) ‚Üí Servlet ‚Üí Filters (reverse) ‚Üí Server ‚Üí Browser

**Request flow detail:**

1. HTTP request arrives at server
2. Server creates request/response objects
3. Passes through filter chain
4. Reaches servlet
5. Servlet processes, generates response
6. Response passes back through filters
7. Server sends HTTP response to browser

### c) Dependency Injection (CDI / Spring DI)

**Problem DI solves:**

- Tight coupling from using `new`
- Hard to test (can't mock dependencies)
- Hard to change implementations
- Lifecycle management scattered
- Manual dependency wiring

**Why `new` is bad in enterprise:**

- Creates tight coupling
- Can't swap implementations
- Can't inject different instance per scope
- Testing requires changing production code
- No lifecycle management

**Who creates objects with DI?** The container (CDI container, Spring container). Based on configuration/annotations. Controls entire lifecycle.

**Object lifecycle management:** Container decides when to create and destroy. Can pool objects, share singletons, create per-request, manage cleanup.

**What is a scope?** Defines lifetime and visibility of object.

**Scope types:**

- **Singleton**: One instance for entire application. Shared by all users.
- **Request**: New instance per HTTP request. Lives during request processing.
- **Session**: New instance per user session. Lives across multiple requests.
- Others: Prototype, application, conversation, etc.

**Why DI frameworks use proxies?**

- Lazy initialization: Don't create until first use
- Scope management: Request-scoped bean in singleton
- AOP: Method interception for transactions, security
- Circular dependencies: Break circular reference chains

**Problem proxies solve:** Can't inject short-lived scope into long-lived scope directly (request bean into singleton). Proxy intercepts calls and resolves current instance.

### d) EJB (Conceptual)

**Why EJB introduced?** Standardize enterprise patterns. Provide declarative services. Simplify distributed computing. Handle concurrency, transactions, security.

**Problems EJB solved:**

- Manual transaction management
- Thread safety in server apps
- Remote method invocation
- Pooling and lifecycle
- Declarative security

**Stateless vs Stateful:**

- **Stateless**: No conversational state. Can service any request. Pooled efficiently.
- **Stateful**: Maintains state per client. Not pooled same way. More expensive.

**Why stateless preferred?** Scalability. Pooling efficiency. No memory per client. Easier to manage. Easier to cluster.

**Container-managed transactions in EJB:** Developer marks method with transaction attribute. Container starts/commits/rolls back automatically. Declarative, less error-prone.

**Why EJB declined?** Too complex. Too much XML. Heavyweight. Required full app server. Testing difficult. Spring provided simpler alternative.

**EJB ideas in Spring:** Declarative transactions, dependency injection, declarative security, lifecycle management, proxies for AOP.

### e) JNDI

**Why JNDI exists?** Naming and directory service. Lookup resources by name. Decouples location from code. Allows external configuration.

**Why not `new` for EJBs?** Container manages EJB lifecycle. Container provides pooling. Container adds interceptors. JNDI gives reference to container-managed proxy.

**InitialContext:** Entry point to JNDI tree. Creates connection to naming service. Used to perform lookups.

**What lookup() returns:** Reference to resource. Could be EJB stub, DataSource, JMS connection factory. Often a proxy, not actual object.

**Local vs Remote JNDI:**

- **Local**: Same JVM, faster, pass by reference
- **Remote**: Different JVM, network call, pass by serialization

**Why remote JNDI tightly coupled?** Client must know server location. Client needs server's stub classes. Server changes affect client. Network topology embedded in code.

**Why JNDI rarely used now?** Dependency injection replaced most use cases. Configuration externalization better achieved other ways. Too much indirection. Spring removed need.

---

## 4Ô∏è‚É£ Transaction Management (CRITICAL)

**What is a transaction?** Unit of work that succeeds or fails as a whole. Either all operations complete or none do. Maintains data consistency.

**Why transactions needed?** Multiple database operations must be atomic. Prevent partial updates. Maintain data integrity. Handle failures gracefully.

**ACID in real systems:**

- **Atomicity**: All-or-nothing execution
- **Consistency**: Valid state before and after
- **Isolation**: Transactions don't interfere with each other
- **Durability**: Committed changes permanent

**Partial failure handling:** Transaction rolls back. Database returns to pre-transaction state. Changes undone. Application must handle failure (retry, report error, compensate).

**Container-managed transaction:** Container starts transaction. Container commits at method end. Container rolls back on exception. Developer declares behavior, container implements.

**What @Transactional does:** Marks transaction boundary. Container/framework wraps method in transaction. Opens DB connection, begins transaction, commits on success, rolls back on exception.

**Transaction lifecycle:**

- **Start**: Method entry (annotated with @Transactional)
- **End**: Method return (commit) or exception (rollback)
- Boundary is method entry/exit

**What causes rollback?** RuntimeException (unchecked) by default. Explicit rollback call. Configured exceptions. Transaction timeout.

**Why runtime exceptions trigger rollback?** Assumption: Runtime exceptions = programming errors or unexpected conditions. Usually can't recover. Data might be inconsistent. Safe default: rollback.

**Transaction propagation:** What happens when transactional method calls another transactional method?

Types:

- **REQUIRED** (default): Join existing or create new
- **REQUIRES_NEW**: Always create new, suspend existing
- **NESTED**: Nested transaction, can roll back without affecting outer
- **SUPPORTS**: Join if exists, non-transactional if not

**Why nested transactions tricky?** Savepoints support database-dependent. Rollback behavior complex. Mixing propagation types confusing. Can cause subtle bugs.

**Distributed transaction:** Transaction spanning multiple databases or resources. Two-phase commit protocol. Coordinator ensures all-or-nothing across resources.

**Why avoid distributed transactions?**

- Slow (multiple round trips)
- Complex failure modes
- Poor scalability
- Coordinator is single point of failure
- Modern systems prefer eventual consistency

---

## 5Ô∏è‚É£ Persistence Layer (JPA / Hibernate)

**Problem ORM solves:**

- Manual JDBC is repetitive
- Object-relational impedance mismatch
- SQL scattered everywhere
- No object identity management
- Manual mapping between objects and rows

**What is an entity?** Java object mapped to database table. Managed by persistence context. Has identity (@Id). Persistent across sessions.

**Entity lifecycle:**

- **Transient**: New object, not managed, no DB row
- **Managed**: Tracked by persistence context, changes auto-saved
- **Detached**: Was managed, no longer tracked
- **Removed**: Marked for deletion

**Persistence context:** First-level cache. Tracks entity instances. Ensures one Java object per DB row (identity). Detects changes automatically. Writes changes at flush/commit.

**Why Hibernate tracks entities?** Automatic dirty checking. Write-behind optimization. Identity guarantees. Lazy loading support. Relationship management.

**Lazy vs Eager loading:**

- **Lazy**: Load related entities when accessed (SELECT on-demand)
- **Eager**: Load related entities immediately (JOIN in original query)

**N+1 problem:** Query returns N items. Each item triggers another query for relationship. Results in N+1 queries instead of 1 with JOIN. Major performance killer.

**First-level cache:** Persistence context itself. Session-scoped. Ensures repeated queries for same entity return same Java object. Prevents multiple DB hits for same row in one session.

**Why transactions for reads?** Persistence context needs transaction boundary. Lazy loading needs open connection. Consistent view of data. Entity tracking requires transaction scope.

**DB connection lifecycle:**

- Opened when transaction starts
- Held during transaction
- Returned to pool at commit/rollback
- Don't hold long (connection pool exhaustion)

**Performance problems in production:**

- Local: Small data, fast DB
- Production: Large data, network latency, concurrent users
- Lazy loading across network = slow
- N+1 queries invisible with small datasets
- Connection pool exhaustion under load

---

## 6Ô∏è‚É£ REST & Web APIs

**What is REST?** Architectural style for distributed systems. Resources identified by URLs. Standard HTTP methods. Stateless communication. Representations (JSON, XML).

**Why REST is stateless?** Scalability: Any server handles any request. Simplicity: No session state. Reliability: No session to lose. Caching: Easier to cache stateless responses.

**Role of HTTP methods:** Semantic meaning. Standard operations on resources.

- **GET**: Retrieve (safe, idempotent)
- **POST**: Create (not idempotent)
- **PUT**: Update/replace (idempotent)
- **DELETE**: Remove (idempotent)
- **PATCH**: Partial update

**GET vs POST:**

- **GET**: Retrieve data, no side effects, cacheable, idempotent
- **POST**: Create resources, has side effects, not cacheable, not idempotent

**HTTP status codes:** Communicate outcome to client. Allows generic error handling. Standard across systems.

- **2xx**: Success
- **3xx**: Redirection
- **4xx**: Client error
- **5xx**: Server error

**Serialization:** Converting Java objects to bytes/text for transmission. JSON, XML, etc. Reverse is deserialization.

**JSON to Java objects:** Serialization library (Jackson, Gson). Uses reflection. Matches JSON fields to Java fields. Handles type conversion.

**Where validation happens:**

- Controller/API layer: Input validation, format checks
- Service layer: Business rule validation
- Both: Different concerns, both needed

**Exception handling in APIs:** Catch exceptions globally. Return appropriate HTTP status. Consistent error format. Never expose stack traces. Log for debugging.

---

## 7Ô∏è‚É£ Spring Framework

**Spring IoC container:** Manages objects (beans). Creates instances based on configuration. Injects dependencies. Manages lifecycle. Central registry of all beans.

**Spring DI vs CDI:**

- **Spring**: Framework-specific, more features, Boot integration
- **CDI**: Java EE standard, portable across containers
- Both solve same problem differently

**Problem Spring Boot solves:**

- Auto-configuration: Sensible defaults
- Embedded server: No separate container needed
- Starter dependencies: Curated dependency sets
- Opinionated: Convention over configuration
- Faster development, less boilerplate

**Auto-configuration:** Spring Boot detects classes on classpath. Automatically configures beans. Provides sensible defaults. Can be overridden. Example: DataSource auto-configured if DB driver present.

**How Spring replaced EJB:** Lighter weight. POJO-based (no interfaces required). No container required. Easier testing. Same functionality, less complexity.

**How Spring removed JNDI need:** Dependency injection replaces lookup. Configuration externalization. No naming service needed. Direct bean references.

**Spring transaction management:** AOP-based. Proxy wraps transactional methods. Opens/commits/rolls back transactions. Declarative via @Transactional. Pluggable transaction managers.

**Spring Data JPA:** Repository abstraction. Generates implementations from method names. Reduces boilerplate. Query derivation. Still uses JPA underneath.

**Why externalized configuration?** Different behavior per environment. No recompilation needed. Secrets not in code. Easy to change. 12-factor app principle.

---

## 8Ô∏è‚É£ Security

**Authentication:** Proving identity. "Who are you?" Username/password, tokens, certificates, biometrics.

**Authorization:** Determining permissions. "What can you do?" Role-based, permission-based. Happens after authentication.

**Security in request flow:** Early in filter chain. Before business logic. After request parsing. Creates security context for downstream.

**Session-based auth:** Server stores session. Cookie references session. Stateful. Scalability challenges. Simple for traditional web apps.

**Token-based auth:** Token contains claims. Stateless. Scalable (no server session). Good for APIs/SPAs. JWT common implementation.

**What JWT solves:** Stateless authentication. Self-contained (no server lookup). Can verify without database. Portable across services.

**Why security is hard:** Many attack vectors. Easy to make mistakes. Evolving threats. Complexity (authentication, authorization, encryption, etc.). One mistake = breach.

---

## 9Ô∏è‚É£ Messaging & Async Processing

**Why async processing?** Decouple sender from receiver. Handle varying loads. Non-blocking operations. Better resource utilization. Resilience.

**Problems messaging solves:**

- Decoupling: Services don't call each other directly
- Load leveling: Queue absorbs spikes
- Reliability: Guaranteed delivery
- Scalability: Add consumers independently

**JMS vs Kafka (conceptual):**

- **JMS**: Queue/topic model, transactional, traditional enterprise
- **Kafka**: Distributed log, high throughput, streaming, replay capability

**Message-driven processing:** Consumer waits for messages. Processes asynchronously. Container manages message delivery. Transactions per message.

**Why events in distributed systems?** Loose coupling. Services react to events. No direct dependencies. Easier to evolve. Captures business intent.

---

## üîü Configuration & Environment

**Why not hard-code config?** Different values per environment. Security (passwords in code). Flexibility (change without recompile). Deployment simplicity.

**Why different behavior per environment?** Different infrastructure (URLs, DB connections). Different secrets. Different features (debugging). Different scale.

**Externalized configuration:** Config outside code. Properties files, environment variables, config servers. Loaded at runtime. Environment-specific.

**"Works on my machine":** Different environments. Different data. Different configuration. Different versions. Different resources.

**Secret management:** Never in code. Never in version control. Use secret managers (Vault, cloud providers). Environment variables. Encrypted config files. Rotate regularly.

---

## 1Ô∏è‚É£1Ô∏è‚É£ Observability & Stability

**Why logging important?** Production debugging. Audit trail. Performance analysis. Error investigation. Only window into production behavior.

**What to log:**

- Errors and exceptions
- Business events
- Entry/exit of important operations
- Performance metrics
- Security events

**What NOT to log:**

- Passwords, secrets
- Personal data (PII)
- Credit cards
- Too much detail (log spam)

**Why production debugging hard?** No debugger. Can't reproduce locally. Intermittent issues. Multiple servers. Real user data constraints.

**Metrics:** Quantitative measurements. Response times, error rates, throughput. Aggregated over time. Alerts based on thresholds.

**Why monitoring > debugging:** Proactive vs reactive. Catch issues before users report. Trends and patterns. Scale problems invisible to debugging. Business insights.

---

## 1Ô∏è‚É£2Ô∏è‚É£ Modern Architecture Awareness

**Problem microservices solve:**

- Independent deployment
- Technology diversity
- Team autonomy
- Scalability (scale parts independently)
- Fault isolation

**Problems microservices introduce:**

- Distributed system complexity
- Network latency
- Data consistency challenges
- Testing complexity
- Operational overhead
- Monitoring/debugging harder

**Why monoliths still exist?** Simpler for small teams. Easier to develop initially. Transactions are easy. Deployment is simpler. Right tool for many problems.

**Service communication:**

- Synchronous: HTTP/REST, gRPC
- Asynchronous: Messaging (Kafka, RabbitMQ)
- Both: Depends on use case

**API Gateway:** Entry point for clients. Routes requests to services. Cross-cutting concerns (auth, rate limiting, logging). Protocol translation. Aggregation.

---

## Additional Essential Concepts

### Idempotency

**What it is:** Operation produces same result when called multiple times. Critical for reliability.

**Why it matters:**

- Network retries safe
- Duplicate requests harmless
- Failure recovery simplified
- Required for PUT, DELETE in REST

### Circuit Breaker Pattern

**Purpose:** Prevent cascading failures. When downstream service fails, stop calling it. Give it time to recover.

**How it works:**

- **Closed**: Normal operation
- **Open**: Stop calling failed service, return error immediately
- **Half-open**: Try occasional request to see if recovered

### Connection Pooling

**Why pools?**

- Creating connections expensive
- Reuse connections
- Limit total connections
- Better performance

**Configuration matters:** Too few = requests wait. Too many = database overwhelmed. Must tune for workload.

### Caching Strategies

**Where to cache:**

- Application level (in-memory)
- Database level (query cache)
- HTTP level (reverse proxy)
- CDN (static content)

**Invalidation:** Hardest problem. Stale data vs performance. Time-based vs event-based.

### Health Checks

**Purpose:** Load balancer knows service is healthy. Automatic failover. Monitoring/alerting.

**What to check:**

- Application running
- Database accessible
- Dependencies reachable
- Critical resources available

---

## How It All Connects

1. **Request arrives** ‚Üí Filter chain ‚Üí Security ‚Üí Controller
2. **Controller** ‚Üí Validates input ‚Üí Calls service
3. **Service** ‚Üí Transaction starts ‚Üí Business logic ‚Üí Calls repository
4. **Repository** ‚Üí JPA query ‚Üí Persistence context ‚Üí Database
5. **Database** ‚Üí Returns data ‚Üí Managed entities ‚Üí Back through layers
6. **Transaction commits** ‚Üí Changes flushed ‚Üí Connection returned to pool
7. **Response serialized** ‚Üí JSON ‚Üí Filters ‚Üí Client

**Key insight:** Each layer has clear responsibility. Framework handles infrastructure. You write business logic. Understanding the flow and "why" each piece exists makes you effective.